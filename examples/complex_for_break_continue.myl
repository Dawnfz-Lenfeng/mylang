// Test complex break and continue scenarios

// Test 1: Multiple breaks and continues in same loop
let processed_items = 0;
let skipped_items = 0;
let i;
for i = 0; i < 10; i += 1 {
    if i == 2 {
        skipped_items += 1;
        continue;
    }

    if i == 5 {
        skipped_items += 1;
        continue;
    }

    if i == 8 {
        break;
    }

    processed_items += 1;
}
assert(i == 8, "Loop should break at count = 8");
assert(processed_items == 6, "Should process 6 items (0,1,3,4,6,7)");
assert(skipped_items == 2, "Should skip 2 items (2,5)");

// Test 2: Break and continue with function calls
fn should_skip(n) {
    return n == 3 or n == 6;
}

fn should_break(n) {
    return n > 7;
}

let function_processed = 0;
let i;
for i = 0; i < 10; i += 1 {
    if should_skip(i) {
        continue;
    }
    
    if should_break(i) {
        break;
    }

    function_processed += 1;
}
assert(i == 8, "Function-based loop should break at i = 8");
assert(function_processed == 6, "Should process 6 numbers (0,1,3,4,6,7)");

// Test 3: Deeply nested with mixed break/continue
let outer_iterations = 0;
let middle_skips = 0;
let inner_breaks = 0;
let total_values = 0;

for let i = 0; i < 3; i += 1 {
    outer_iterations += 1;

    for let j = 0; j < 4; j += 1 {
        if j == 2 {
            middle_skips += 1;
            continue; // Skip middle == 2
        }

        for let k = 0; k < 3; k += 1 {
            if k == 2 and j == 3 {
                inner_breaks += 1;
                break;
            }
            total_values += 1;
        }

        if j == 3 {
            break;
        }
    }
}

assert(outer_iterations == 3, "Should complete 3 outer iterations");
assert(middle_skips == 3, "Should skip middle=3 three times");
assert(inner_breaks == 3, "Should break inner loop 3 times at middle=3, inner=2");
assert(total_values == 24, "Should process correct number of values");

print "All complex break/continue tests passed!";
