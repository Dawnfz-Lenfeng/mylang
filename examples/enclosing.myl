// Test enclosing scope and closure behavior
fn wrapper() {
    let a = 0;

    fn inner() {
        a = a + 1;
        return a;
    }

    return inner;
}

let increase = wrapper();

// Test that closure captures and modifies the enclosing variable
assert(increase() == 1, "First call should return 1");
assert(increase() == 2, "Second call should return 2");
assert(increase() == 3, "Third call should return 3");

// Test that multiple closures from same factory are independent
let increase2 = wrapper();
assert(increase2() == 1, "New closure should start from 1");
assert(increase() == 4, "Original closure should continue from where it left off");
assert(increase2() == 2, "Second closure should be at 2");

// Test more complex enclosing scope
fn create_adder(base) {
    let total = base;
    
    fn add(amount) {
        total = total + amount;
        return total;
    }
    
    fn get_total() {
        return total;
    }
    
    return add;
}

let adder1 = create_adder(10);
let adder2 = create_adder(100);

assert(adder1(5) == 15, "Adder1 should be 10+5=15");
assert(adder2(20) == 120, "Adder2 should be 100+20=120");
assert(adder1(3) == 18, "Adder1 should be 15+3=18");
assert(adder2(5) == 125, "Adder2 should be 120+5=125");

print "All enclosing scope tests passed!";
